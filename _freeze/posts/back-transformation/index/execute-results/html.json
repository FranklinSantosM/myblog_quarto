{
  "hash": "5e95dedde8b0a70bb19cdc56871ce578",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Back-transformations with emmeans() in R\"\ndescription: |\n  Transformaciones inversas: Regresando a la escala original en el análisis de datos.\ncategories: [R, Normalidad, Transformation]\nauthor:\n  - name: Franklin Santos\n    url: https://www.franklinsantosm.com\n    affiliation: Universidad Austral de Chile\n    orcid: 0000-0002-7509-2910\n    email: franklin25santos@gmail.com\ndate: \"2024-08-06\"\nimage: fs.png\ncitation: true\neditor_options: \n  chunk_output_type: console\n---\n\n```{=html}\n<style>\nbody {\ntext-align: justify}\n</style>\n```\n\n\n\n## Introducción \n\nEn el análisis de datos, especialmente en disciplinas como la estadística y el machine learning, es común aplicar transformaciones a los datos para mejorar la calidad de los análisis. Estas transformaciones ayudan a cumplir con supuestos estadísticos como la normalidad o la homogeneidad de varianzas, y a menudo permiten obtener modelos más robustos y precisos. Sin embargo, una vez que hemos realizado el análisis, surge la necesidad de interpretar los resultados en la escala original de los datos. Aquí es donde entran en juego las **transformaciones inversas**.\n\nLas transformaciones inversas son las operaciones matemáticas que revertimos para devolver los datos transformados a su forma original. Esto es crucial cuando queremos comunicar los hallazgos de manera que tengan sentido práctico y comprensible. Por ejemplo, si aplicamos una transformación logarítmica para estabilizar la varianza de un conjunto de datos, la transformación inversa —en este caso, la exponenciación— nos permite expresar los resultados en la misma escala en la que los datos fueron originalmente recolectados.\n\nAlgunas de las transformaciones más comunes incluyen la logarítmica, la raíz cuadrada y la Box-Cox, cada una con su correspondiente transformación inversa. Estas técnicas son especialmente útiles en áreas como la biología, la economía y la ingeniería, donde los datos a menudo no cumplen con las distribuciones ideales para un análisis directo.\n\n## Tipos de transformación\n\nA continuación, te presento algunas de las transformaciones más comunes y sus inversas:\n\n### 1. **Transformación Logarítmica (log)**\n   - **Transformación**: Se utiliza para reducir la asimetría positiva o estabilizar la varianza cuando los datos tienen valores grandes.\n     - Fórmula: $y' = \\log(y)$, generalmente en base natural ($\\log_e$) o base 10.\n   - **Inversa**: La operación inversa es la exponenciación.\n     - Fórmula: $y = e^{y'}$ o $y = 10^{y'}$, dependiendo de la base logarítmica utilizada.\n\n### 2. **Transformación de Raíz Cuadrada**\n   - **Transformación**: Es útil cuando los datos tienen una distribución con una leve asimetría positiva o cuando se busca estabilizar la varianza.\n     - Fórmula: $y' = \\sqrt{y}$\n   - **Inversa**: La inversa de esta transformación es elevar al cuadrado.\n     - Fórmula: $y = (y')^2$\n\n### 3. **Transformación Inversa (1/y)**\n   - **Transformación**: Se utiliza cuando los datos tienen una tendencia lineal negativa o para ajustar relaciones hiperbólicas.\n     - Fórmula: $y' = \\frac{1}{y}$\n   - **Inversa**: La transformación inversa es la operación recíproca.\n     - Fórmula: $y = \\frac{1}{y'}$\n\n### 4. **Transformación de Potencia (Box-Cox)**\n   - **Transformación**: Box-Cox es una familia de transformaciones que busca estabilizar la varianza y normalizar los datos. Se controla con un parámetro $\\lambda$.\n     - Fórmula: $y' = \\frac{y^\\lambda - 1}{\\lambda}$ (si $\\lambda \\neq 0$), o $y' = \\log(y)$ (si $\\lambda = 0$).\n   - **Inversa**: La inversa depende del valor de $\\lambda$.\n     - Si $\\lambda = 0$: $y = e^{y'}$\n     - Si $\\lambda \\neq 0$: $y = (y' \\cdot \\lambda + 1)^{1/\\lambda}$\n\n### 5. **Transformación Logística**\n   - **Transformación**: Se utiliza en modelos de regresión logística, donde se transforma una probabilidad $p$ en el logit (logaritmo de las probabilidades).\n     - Fórmula: $y' = \\log \\left( \\frac{p}{1-p} \\right)$\n   - **Inversa**: La inversa se conoce como la función logística o sigmoide.\n     - Fórmula: $p = \\frac{1}{1 + e^{-y'}}$\n\n### 6. **Transformación de Arcoseno (arcsin)**\n   - **Transformación**: Es usada comúnmente en proporciones o datos de frecuencia que están entre 0 y 1, para normalizarlos.\n     - Fórmula: $y' = \\arcsin(\\sqrt{y})$\n   - **Inversa**: La inversa es la función seno al cuadrado.\n     - Fórmula: $y = (\\sin(y'))^2$\n\n### 7. **Transformación Log-Log**\n   - **Transformación**: Se utiliza cuando tanto la variable dependiente como la independiente están en una escala logarítmica.\n     - Fórmula: $y' = \\log(y)$ y $x' = \\log(x)$\n   - **Inversa**: La exponenciación de ambas variables devuelve a su escala original.\n     - Fórmula: $y = e^{y'}$, $x = e^{x'}$\n     \n## Back-transformations con emmeans()\n\nEn el paquete `emmeans` de R, las **back-transformations** (transformaciones inversas) se utilizan para devolver las estimaciones de medias marginales de los efectos al espacio original de los datos después de que se haya aplicado una transformación en el modelo. Esto es útil cuando se ha ajustado un modelo con una transformación, como una transformación logarítmica o de raíz cuadrada, y deseas interpretar los resultados en la escala original de los datos.\n\n### ¿Cómo funciona?\n\nCuando aplicas una transformación a los datos (por ejemplo, logaritmo), el modelo ajustado trabaja en la escala transformada, y por lo tanto, las estimaciones de medias marginales predichas estarán en esa misma escala. Sin embargo, `emmeans()` permite aplicar automáticamente la transformación inversa, devolviendo las medias estimadas a su escala original para una interpretación más fácil.\n\nEl paquete `emmeans` detecta automáticamente si la transformación se usó en el modelo y aplica la transformación inversa al calcular los **Estimated Marginal Means** (EMMs). Esto se puede controlar utilizando el argumento `type = \"response\"` para realizar la transformación inversa al solicitar los EMMs.\n\n### Ejemplo de uso de `emmeans()` con back-transformations\n\nSupongamos que tienes un modelo lineal generalizado (GLM) con una transformación logarítmica aplicada a la variable de respuesta. A continuación te muestro cómo podrías aplicar una back-transformation usando `emmeans()`:\n\n#### Paso 1: Ajustar el modelo\n\n```r\n# Ejemplo de un GLM con transformación logarítmica\nmodelo <- glm(y ~ tratamiento, family = gaussian(link = \"log\"), data = datos)\n```\n\nEn este caso, `y` es la variable de respuesta transformada mediante un enlace logarítmico.\n\n#### Paso 2: Obtener los EMMs con la transformación inversa\n\n```r\nlibrary(emmeans)\n\n# Obtener las medias marginales estimadas (EMMs) y aplicar back-transformation\nem_means <- emmeans(modelo, ~ tratamiento, type = \"response\")\n```\n\n- El argumento `type = \"response\"` le indica a `emmeans()` que aplique la transformación inversa (en este caso, exponenciación, ya que se usó una transformación logarítmica).\n- Si no se especifica `type = \"response\"`, `emmeans()` devolvería las estimaciones en la escala transformada (logarítmica en este caso).\n\n#### Paso 3: Interpretar los resultados\n\n```r\n# Mostrar los resultados back-transformados\nsummary(em_means)\n```\n\nEsto te mostrará las estimaciones en la escala original de los datos, lo cual es más fácil de interpretar en términos del contexto del problema. Además, los intervalos de confianza también serán transformados inversamente.\n\n### Ejemplo con Transformación de Raíz Cuadrada\n\nSi usas una transformación de raíz cuadrada en lugar de logarítmica, la back-transformation consistirá en elevar al cuadrado los resultados.\n\n#### Paso 1: Ajustar el modelo\n\n```r\nmodelo_sqrt <- lm(sqrt(y) ~ tratamiento, data = datos)\n```\n\n#### Paso 2: Obtener las medias marginales estimadas con la transformación inversa\n\n```r\n# Obtener las medias marginales estimadas con back-transformation (cuadrado)\nem_means_sqrt <- emmeans(modelo_sqrt, ~ tratamiento, type = \"response\")\n```\n\nEn este caso, `emmeans()` elevará las medias estimadas al cuadrado para devolverlas a la escala original.\n\n#### Paso 3: Ver los resultados\n\n```r\nsummary(em_means_sqrt)\n```\n\nCuando usas el paquete `emmeans()` en R, puedes realizar back-transformations fácilmente con el argumento `type = \"response\"`. Este enfoque es útil cuando has ajustado un modelo con una transformación en la variable de respuesta y deseas interpretar las medias estimadas en la escala original de los datos.\n\n## Ejercicio practico\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(emmeans)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'emmeans' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWelcome to emmeans.\nCaution: You lose important information if you filter this package's results.\nSee '? untidy'\n```\n\n\n:::\n\n```{.r .cell-code}\nfileName <- \"http://www.casaonofri.it/_datasets/insects.csv\"\ndataset <- read.csv(fileName)\ndataset$Insecticide <- as.factor(dataset$Insecticide)\ndataset$Count <- as.numeric(dataset$Count)\nhead(dataset)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Insecticide Rep Count\n1          T1   1   448\n2          T1   2   906\n3          T1   3   484\n4          T1   4   477\n5          T1   5   634\n6          T2   1   211\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel <- lm(log(Count) ~ Insecticide, data = dataset)\nemmeans(model, ~Insecticide, type = \"response\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Insecticide response     SE df lower.CL upper.CL\n T1             568.6 101.01 12    386.1    837.3\n T2             335.1  59.54 12    227.6    493.5\n T3              51.9   9.22 12     35.2     76.4\n\nConfidence level used: 0.95 \nIntervals are back-transformed from the log scale \n```\n\n\n:::\n:::\n\n\nDesafortunadamente, no todas las transformaciones son autodetectadas; por ejemplo, consideremos el conjunto de datos 'Hours_to_failure.csv', donde tenemos el tiempo hasta el fallo (en horas) de un dispositivo, afectado por la temperatura de funcionamiento. Si consideramos la temperatura como un factor, podemos ajustar un modelo ANOVA; una comprobación con la función `boxcox()` del paquete `MASS` sugiere que este conjunto de datos podría requerir una transformación estabilizadora en el valor inverso.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\nlibrary(emmeans)\nfileName <- \"http://www.casaonofri.it/_datasets/Hours_to_failure.csv\"\ndataset <- read.csv(fileName)\ndataset$Temp <- factor(dataset$Temp)\nhead(dataset)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Temp Hours_to_failure\n1 1520             1953\n2 1520             2135\n3 1520             2471\n4 1520             4727\n5 1520             6134\n6 1520             6314\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel <- lm(Hours_to_failure ~ Temp, data = dataset)\ntp <- boxcox(model)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(model)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-4.png){width=672}\n:::\n:::\n\n\n\nComo vemos a continuación, la transformación inversa no se detecta automáticamente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel2 <- lm(I(1/Hours_to_failure) ~ Temp, data = dataset)\nemmeans(model2, ~ Temp, type = \"response\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Temp response       SE df lower.CL upper.CL\n 1520 0.000320 9.52e-05 20 0.000121 0.000518\n 1620 0.000579 9.52e-05 20 0.000381 0.000778\n 1660 0.001043 9.52e-05 20 0.000844 0.001241\n 1708 0.001565 9.52e-05 20 0.001366 0.001763\n\nConfidence level used: 0.95 \nIntervals are back-transformed from the identity scale \n```\n\n\n:::\n:::\n\n\n\nEn esta situación, hay que utilizar un enfoque alternativo. La transformación puede realizarse antes de ajustar el modelo; a continuación, tenemos que actualizar la «rejilla de referencia» del modelo, especificando qué tipo de transformación hemos realizado (`tran = \"inverse\"`). Por último, podemos pasar la rejilla actualizada a la función `emmeans()`. Y... ¡la transformación inversa está servida!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndataset$invHours <- 1/dataset$Hours_to_failure\nmodel3 <- lm(invHours ~ Temp, data = dataset)\nupdGrid <- update(ref_grid(model3), tran = \"inverse\")\nemmeans(updGrid, ~Temp, type = \"response\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Temp response    SE df lower.CL upper.CL\n 1520     3128 931.6 20     1930     8258\n 1620     1726 283.6 20     1285     2626\n 1660      959  87.6 20      806     1185\n 1708      639  38.9 20      567      732\n\nConfidence level used: 0.95 \nIntervals are back-transformed from the inverse scale \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(model3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-4.png){width=672}\n:::\n:::\n\n\nA veces, necesito un extra de flexibilidad. Por ejemplo, si nos fijamos en el gráfico 'boxcox' anterior, vemos que la transformación inversa, aunque aceptable (el valor $-1$ está dentro de los límites de confianza para ($\\lambda$) no es la mejor. De hecho, el valor de máxima verosimilitud es -0,62:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntp$x[which.max(tp$y)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.6262626\n```\n\n\n:::\n:::\n\n\nPor lo tanto, podríamos utilizar la siguiente transformación, que está dentro de la familia 'boxcox':\n\n$$\nW = \\frac{Y^{-0,62} - 1}{-0,62}\n$$\n\nEste tipo de transformación no es manejable con el código anterior y necesitamos utilizar la función `make.tran()`, especificando el valor de $\\lambda$ (`alpha = -0.62`) y el valor del parámetro desplazamiento (`beta = 1`).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndataset$bcHours <- (dataset$Hours_to_failure^(-0.62) - 1)/(-0.62)\nmodel4 <- lm(bcHours ~ Temp, data = dataset)\nupdGrid <- update(ref_grid(model4), \n                  tran = make.tran(\"boxcox\", alpha = -0.62,\n                                   beta = 1))\nemmeans(updGrid, ~Temp, type = \"response\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Temp response    SE df lower.CL upper.CL\n 1520     3265 708.8 20     2191     5556\n 1620     1763 260.9 20     1329     2483\n 1660      976 100.0 20      798     1227\n 1708      642  50.7 20      549      764\n\nConfidence level used: 0.95 \nIntervals are back-transformed from the Box-Cox (lambda = -0.62) of (y - 1) scale \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(model4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-4.png){width=672}\n:::\n:::\n\n\n\n\nLa función `make.tran()` puede utilizarse para especificar otras funciones de transformación, como la transformación angular que se utiliza a menudo para porcentajes y proporciones. Puede obtener una lista completa buscando en help (`?make.tran`) desde dentro de R.\n\n## Conclusión \n\nLas transformaciones estabilizadoras, a pesar de su antigüedad, pueden seguir siendo útiles para ajustar modelos heteroscedásticos; ¡no las infravalore sólo porque ya no estén de moda!\n\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}