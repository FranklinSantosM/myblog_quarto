{
  "hash": "22cb37266de3441e4f698104a451337a",
  "result": {
    "markdown": "---\ntitle: \"Análisis de datos climáticos de la E.E. Kallutaca\"\ndescription: |\n  Breve análisis de datos climáticos de la Estación Experimental de Kallutaca, durante la campaña agrícola 2019-2020.\ncategories:\n  - Tidyverse\n  - Climate Analysis\n  - Kallutaca\nauthor:\n  - name: Franklin Santos\n    url: https://franklinsantos.com\n    affiliation: AgriTech Bolivia\n    orcid: 0000-0002-7509-2910\ndate: \"2020-01-02\"\n---\n\n\n# Marcos de datos y Tibbles\n\nCree estructuras de datos tabulares con marcos de datos y vea cómo se comparan con tibbles. Extraiga vectores de columna de marcos de datos para realizar cálculos. Obtenga información de metadatos como dimensiones. Seleccione las filas superior e inferior para obtener una descripción general rápida.\n\n## Construye un marco de datos a partir de vectores\n\nLos datos tabulares son el formato más común utilizado por los científicos de datos. En R, las tablas se representan mediante marcos de datos. Pueden inspeccionarse imprimiéndolos en la consola.\n\n* Comprender por qué los marcos de datos son importantes\n* Interpretar la salida de la consola creada por un marco de datos\n* Cree un nuevo marco de datos usando la función `data.frame()`\n* Definir los vectores que se utilizarán para columnas individuales\n* Especificar los nombres de las columnas del marco de datos\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(___ = ___, \n           ___ = ___, \n           ...)\n```\n:::\n\n\n### Introducción a los marcos de datos\n\nEn análisis y estadísticas, los datos tabulares son la estructura de datos más importante. Está presente en muchos formatos comunes como archivos de Excel, valores separados por comas (CSV) o bases de datos. R integra objetos de datos tabulares como ciudadanos de primera clase en el idioma a través de *marcos de datos*. Los marcos de datos permiten a los usuarios leer y manipular fácilmente datos tabulares dentro del lenguaje R.\n\nEchemos un vistazo a un objeto de marco de datos llamado `Davis`, del paquete **carData**, que incluye medidas de altura y peso para 200 hombres y mujeres:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble (Davis)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 200 × 5\n   sex   weight height repwt repht\n   <fct>  <int>  <int> <int> <int>\n 1 M         77    182    77   180\n 2 F         58    161    51   159\n 3 F         53    161    54   158\n 4 M         68    177    70   175\n 5 F         59    157    59   155\n 6 M         76    170    76   165\n 7 M         76    167    77   165\n 8 M         69    186    73   180\n 9 M         71    178    71   175\n10 M         65    171    64   170\n# … with 190 more rows\n```\n:::\n:::\n\n\nDe la salida impresa, podemos ver que el marco de datos abarca más de 200 **filas** y 5 **columnas**. En el ejemplo anterior, cada fila contiene datos de una persona a través de **atributos**, que corresponden a las columnas `sex`, `weight`, `height`, `repwt` (peso reportado) y `repht` (altura reportado).\n\nPor ejemplo, la primera fila de la tabla especifica un hombre que pesa `77` kg y tiene una altura de `182` cm. Los pesos reportados están muy cerca de `77` kg y `180` cm, respectivamente.\n\nLas filas en un marco de datos se identifican además por los *nombres de fila* a la izquierda, que son simplemente los números de fila por defecto. En el caso del conjunto de datos de `Davis` anterior, los nombres de las filas van de 1 a 200.\n\n### Crear marcos de datos\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(___ = ___, \n           ___ = ___, \n           ...)\n```\n:::\n\n\nLos marcos de datos contienen datos tabulares en varias columnas o *atributos*. Cada columna está representada por un vector de diferentes *tipos de datos* como números o caracteres. La función `data.frame()` admite la construcción de objetos de marco de datos combinando diferentes vectores en una tabla. Para formar una tabla, se requiere que los vectores tengan la misma longitud. Un marco de datos también puede verse como una colección de vectores conectados entre sí para formar una tabla.\n\nCreemos nuestro primer marco de datos con cuatro personas diferentes, incluidos sus identificadores, nombres e indicadores si son mujeres o no. Cada uno de estos atributos es creado por un vector diferente de diferentes tipos de datos (numéricos, de caracteres y lógicos). Los atributos finalmente se combinan en una tabla usando la función `data.frame()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\n  c(1, 2, 3, 4),\n  c(\"Louisa\", \"Jonathan\", \"Luigi\", \"Rachel\"),\n  c(TRUE, FALSE, FALSE, TRUE)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  c.1..2..3..4. c..Louisa....Jonathan....Luigi....Rachel..\n1             1                                     Louisa\n2             2                                   Jonathan\n3             3                                      Luigi\n4             4                                     Rachel\n  c.TRUE..FALSE..FALSE..TRUE.\n1                        TRUE\n2                       FALSE\n3                       FALSE\n4                        TRUE\n```\n:::\n:::\n\n\nEl marco de datos resultante almacena los valores de cada vector en una columna diferente. Tiene cuatro filas y tres columnas. Sin embargo, los nombres de las columnas impresas en la primera línea parecen incluir los valores de las columnas separados por puntos, lo cual es un esquema de nombres muy extraño.\n\nLos nombres de columna se pueden incluir en la construcción de `data.frame()` como nombres de argumentos que preceden a los valores de los vectores de columna. Para mejorar el nombre de la columna del marco de datos anterior, podemos escribir\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(\n  id = c(1, 2, 3, 4),\n  name = c(\"Louisa\", \"Jonathan\", \"Luigi\", \"Rachel\"),\n  female = c(TRUE, FALSE, FALSE, TRUE)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id     name female\n1  1   Louisa   TRUE\n2  2 Jonathan  FALSE\n3  3    Luigi  FALSE\n4  4   Rachel   TRUE\n```\n:::\n:::\n\n\nEl marco de datos resultante incluye los nombres de columna necesarios para ver el significado real de las diferentes columnas.\n\n## Crea y convierte tibbles\n\nTibbles son la reimaginación moderna de marcos de datos y comparten muchos puntos en común con sus antepasados. La diferencia más visible es cómo se imprime el contenido de tibble en la consola. Tibbles son parte del tidyverse y se utilizan por su comportamiento más consistente en comparación con los marcos de datos.\n\n* Conozca la diferencia entre *marcos de datos* y *tibbles*\n* Crear *tibbles* a partir de vectores\n* Convertir *marcos de datos* en tibbles\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(___ = ___, \n       ___ = ___, \n       ...)\nas_tibble(___)\n```\n:::\n\n\n### Introducción a Tibbles\n\n>Una reinvención moderna del marco de datos\n<https://tibble.tidyverse.org>\n\nTibbles son en muchos aspectos similares a los marcos de datos. De hecho, se *heredan* de los marcos de datos, lo que significa que todas las funciones y características disponibles para los marcos de datos también funcionan para tibbles. Por tanto, cuando hablamos de *marcos de datos* también nos referimos a *tibbles*.\n\nAdemás de todo lo que ofrece un marco de datos, los tibbles tienen un comportamiento más consistente con una mejor usabilidad en muchos casos. Lo más importante es que cuando se imprime un objeto tibble en la consola, muestra automáticamente solo las primeras 10 filas y condensa columnas adicionales. Por el contrario, un marco de datos llena toda la pantalla de la consola con valores que pueden generar confusión. Echemos un vistazo al conjunto de datos `gapminder` del paquete **gapminder**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder::gapminder\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# … with 1,694 more rows\n```\n:::\n:::\n\n\nInmediatamente vemos que el conjunto de datos `gapminder` es un tibble que consta de 1,704 filas y 6 columnas en la línea superior. En la segunda línea podemos ver los nombres de las columnas y sus correspondientes *tipos de datos* directamente debajo.\n\nPor ejemplo, la columna `country` tiene el tipo `<fct>` (que es la abreviatura de \"factor\"), `year` es un número entero `<int>` y la esperanza de vida `lifeExp` es un `<dbl>`, un número decimal.\n\n### Creando Tibbles\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(___ = ___, \n       ___ = ___, \n       ...)\nas_tibble(___)\n```\n:::\n\n\nLa creación de tibbles funciona exactamente igual que para los marcos de datos. Podemos usar la función `tibble()` del paquete **tibble** para crear un nuevo objeto tabular.\n\nPor ejemplo, un tibble que contenga datos de cuatro personas diferentes y tres columnas se puede crear así:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\ntibble(\n  id = c(1, 2, 3, 4),\n  name = c(\"Louisa\", \"Jonathan\", \"Luigi\", \"Rachel\"),\n  female = c(TRUE, FALSE, FALSE, TRUE)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n     id name     female\n  <dbl> <chr>    <lgl> \n1     1 Louisa   TRUE  \n2     2 Jonathan FALSE \n3     3 Luigi    FALSE \n4     4 Rachel   TRUE  \n```\n:::\n:::\n\n\n### Conversión de marcos de datos a Tibbles\n\nSi prefiere tibbles a marcos de datos por sus características adicionales, también se pueden convertir a partir de marcos de datos existentes con la función `as_tibble()`.\n\nPor ejemplo, el marco de datos de `Davis` del paquete **carData** se puede convertir a un tibble así:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_tibble(Davis)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 200 × 5\n   sex   weight height repwt repht\n   <fct>  <int>  <int> <int> <int>\n 1 M         77    182    77   180\n 2 F         58    161    51   159\n 3 F         53    161    54   158\n 4 M         68    177    70   175\n 5 F         59    157    59   155\n 6 M         76    170    76   165\n 7 M         76    167    77   165\n 8 M         69    186    73   180\n 9 M         71    178    71   175\n10 M         65    171    64   170\n# … with 190 more rows\n```\n:::\n:::\n\n\n## Extraiga o reemplace columnas en un marco de datos usando $\n\nLas columnas de un marco de datos se pueden extraer y manipular fácilmente con el operador `$`. Incluso se pueden agregar nuevas columnas asignando un vector.\n\n* Extraiga columnas de un marco de datos con `$`.\n* Reemplazar valores de columnas existentes en un marco de datos.\n* Agregue nuevas columnas a un marco de datos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n___$___\n___$___  <- ___\n```\n:::\n\n\n### Extraer columnas con $\n\nLos marcos de datos son tablas que resultan de la combinación de vectores de columna. Los usuarios pueden interactuar con los marcos de datos a través de numerosos operadores para extraer, agregar o recombinar valores. Para extraer columnas individuales de un marco de datos, R ofrece un operador muy específico: el dólar `$`. Devuelve el vector de columna como lo indica su nombre basado en un marco de datos que precede a `$`.\n\nPara ver el operador `$` en acción, extraigamos la población `pop` (en 1,000) de diferentes estados de los EE. UU. Según el conjunto de datos de los estados (de 1992) en el paquete **carData**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncarData::States$pop\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  4041   550  3665  2351 29760  3294  3287   666   607 12938  6478  1108\n[13]  1007 11431  5544  2777  2478  3685  4220  1228  4781  6016  9295  4375\n[25]  2573  5117   799  1578  1202  1109  7730  1515 17990  6629   639 10847\n[37]  3146  2842 11882  1003  3487   696  4877 16987  1723   563  6187  4867\n[49]  1793  4892   454\n```\n:::\n:::\n\n\nEl comando extrae la columna de población como vector del marco de datos. A partir de este vector podemos calcular la `sum()` de la población total como:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(States$pop)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 248709\n```\n:::\n:::\n\n\nDe manera similar, el salario promedio (en $1,000) de los maestros se puede calcular como la `mean()` de la columna `pay`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(States$pay)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 30.94118\n```\n:::\n:::\n\n\n## Determinar el tamaño de un marco de datos\n\nEl tamaño de un marco de datos, como el número de filas o columnas, a menudo es necesario y se puede determinar de varias formas.\n\n* Obtener el número de filas de un marco de datos\n* Obtener el número de columnas de un marco de datos\n* Obtener dimensiones de un marco de datos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(___)\nncol(___)\ndim(___)\nlength(___)\n```\n:::\n\n\n### Dimensiones del marco de datos\n\nEl número de filas y columnas en un marco de datos se puede adivinar a través de la salida impresa del marco de datos. Sin embargo, es mucho más fácil obtener esta información directamente a través de funciones. Además, es posible que desee utilizar esta información en algunas partes del código.\n\nLos marcos de datos tienen dos dimensiones. El número de filas se considera la primera dimensión. Por lo general, define el número de observaciones en un conjunto de datos. Para obtener el número de filas del marco de datos de `Davis` en el conjunto de datos **carData**, use la función `nrow()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(Davis)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 200\n```\n:::\n:::\n\n\nDe manera similar, el número de columnas o *atributos* del marco de datos se puede recuperar con `ncol()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nncol(Davis)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n### Recuperar las dimensiones del marco de datos\n\nPara recuperar el tamaño de todas las dimensiones de un marco de datos a la vez, puede usar la función `dim()`. `dim()` devuelve un vector con dos elementos, el primer elemento es el número de filas y el segundo elemento el número de columnas.\n\nPor ejemplo, las dimensiones del conjunto de datos de `Davis` se pueden recuperar como:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(Davis)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 200   5\n```\n:::\n:::\n\n\nAdemás de los marcos de datos, `dim()` también se puede utilizar para otros objetos R multidimensionales, como matrices. Sin embargo, cuando se usa con vectores `dim` solo devuelve `NULL`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(c(1, 3, 5, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\nEn cambio, la longitud de un vector se determina mediante `length()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(c(1, 3, 5, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nEn el caso de un marco de datos, `length()` devuelve su número de columnas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(Davis)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n## Seleccionar la primera o la última fila de un marco de datos\n\nA menudo no necesitamos mirar todo el contenido de un marco de datos en la consola. En cambio, solo algunas partes son suficientes, como la parte superior o inferior recuperada a través de las funciones `head()` y `tail()`.\n\n* Seleccionar la parte superior de un marco de datos\n* Seleccione la parte inferior de un marco de datos\n* Especifique el número de líneas a seleccionar mediante el parámetro n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(___, n = ___)\ntail(___, n = ___)\n```\n:::\n\n\n### Seleccionar la parte superior de un marco de datos\n\nLos marcos de datos pueden abarcar una gran cantidad de filas y columnas. Según la salida impresa en la consola, puede ser difícil obtener una impresión inicial de los datos dentro del marco de datos. Este problema no es tanto un problema para tibbles que tienen una mejor salida de consola. Además, puede ser útil recuperar fácilmente las primeras filas en un comando sin indexación ni paquetes adicionales.\n\nEl conjunto de datos `TitanicSurvival` contiene datos de 1309 pasajeros representados como filas. Una simple impresión del conjunto de datos imprimiría a todos los pasajeros, llenando toda la consola. En cambio, la función `head()` muestra solo las primeras 10 filas de un marco de datos, incluidos los nombres de sus columnas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(TitanicSurvival)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                                survived    sex     age passengerClass\nAllen, Miss. Elisabeth Walton        yes female 29.0000            1st\nAllison, Master. Hudson Trevor       yes   male  0.9167            1st\nAllison, Miss. Helen Loraine          no female  2.0000            1st\nAllison, Mr. Hudson Joshua Crei       no   male 30.0000            1st\nAllison, Mrs. Hudson J C (Bessi       no female 25.0000            1st\nAnderson, Mr. Harry                  yes   male 48.0000            1st\n```\n:::\n:::\n\n\nEl número de columnas se puede ajustar mediante el parámetro `n`. Para extraer solo las primeras tres filas del conjunto de datos, puede escribir:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(TitanicSurvival, n = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                               survived    sex     age passengerClass\nAllen, Miss. Elisabeth Walton       yes female 29.0000            1st\nAllison, Master. Hudson Trevor      yes   male  0.9167            1st\nAllison, Miss. Helen Loraine         no female  2.0000            1st\n```\n:::\n:::\n\n\n### Seleccionar la parte inferior de un marco de datos\n\nLa función `tail()` se puede utilizar para seleccionar las filas inferiores de un marco de datos. Similar a la función `head()`, también acepta un parámetro `n` para especificar el número de filas que se devolverán.\n\nPor ejemplo, para seleccionar las últimas cinco filas del conjunto de datos `TitanicSurvival`, puede escribir:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(TitanicSurvival, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                          survived    sex  age passengerClass\nZabour, Miss. Hileni            no female 14.5            3rd\nZabour, Miss. Thamine           no female   NA            3rd\nZakarian, Mr. Mapriededer       no   male 26.5            3rd\nZakarian, Mr. Ortin             no   male 27.0            3rd\nZimmerman, Mr. Leo              no   male 29.0            3rd\n```\n:::\n:::\n\n\nLas funciones de cabeza y cola también se pueden combinar para seleccionar un fragmento del conjunto de datos del medio. Para seleccionar las primeras cinco filas de las 500 filas inferiores, puede escribir:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(tail(TitanicSurvival, n = 500), n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                                survived    sex age passengerClass\nFord, Mr. Edward Watson               no   male  18            3rd\nFord, Mr. William Neal                no   male  16            3rd\nFord, Mrs. Edward (Margaret Ann       no female  48            3rd\nFox, Mr. Patrick                      no   male  NA            3rd\nFranklin, Mr. Charles (Charles        no   male  NA            3rd\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}