{
  "hash": "9fa968b5d264803b9d39897ff2edb907",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Diseño Completamente al Azar\"\ndescription: |\n  El diseño más sencillo desde el punto de vista de la asignación de unidades experimentales a los tratamientos.\ncategories: [RCD, Experimental Design, Plant Breeding]\nauthor:\n  - name: Franklin Santos\n    url: https://www.franklinsantosm.com\n    affiliation: Universidad Austral de Chile\n    orcid: 0000-0002-7509-2910\n    email: franklin25santos@gmail.com\ndate: \"2024-06-12\"\nimage: fsm.png\ncitation: true\neditor_options: \n  chunk_output_type: console\n---\n\n```{=html}\n<style>\nbody {\ntext-align: justify}\n</style>\n```\n\n\n## 1. Diseño completamente aleatorizado (DCA)\n\nEl diseño más sencillo desde el punto de vista de la asignación de unidades experimentales a los tratamientos.\n\n#### **Supuestos:**\n\n 1. Distribución normal de residuos\n 2. Homogeneidad de varianzas\n 3. Observaciones independientes \n \n\n### **Ventajas:**\n\n * Simplicidad\n * Evita hacer suposiciones estadísticas dudosas.\n * Pocas violaciones de los supuestos.\n * El análisis estadístico es sencillo.\n\n### **Desventaja:**\n \n * Falta de precisión o incapacidad para estimar con precisión los efectos del tratamiento.\n\n## Paquetes\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (install &) load packages\npacman::p_load(\n  conflicted,\n  desplot,\n  emmeans,\n  ggtext,\n  multcomp,\n  multcompView,\n  tidyverse,\n  lme4)\n\n# handle function conflicts\nconflicts_prefer(dplyr::filter) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n[conflicted] Will prefer dplyr::filter over any other package.\n```\n\n\n:::\n\n```{.r .cell-code}\nconflicts_prefer(dplyr::select)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n[conflicted] Will prefer dplyr::select over any other package.\n```\n\n\n:::\n:::\n\n\n## Base de datos\n\nEste ejemplo procede del \"Ejemplo 4.3\" del material didáctico \"Métodos cuantitativos en biociencias (3402-420)\" del [Prof. Dr. Hans-Peter Piepho](https://www.uni-hohenheim.de/organisation?tx_base_lsfcontentadmin%5BlsfPerson%5D=6257). Considera los datos publicados en la p.52 de Mead, Curnow, y Hasted (2002) de un ensayo de rendimiento con melones. El ensayo tenía 4 variedades de melón (variedad). Cada variedad se probó en seis parcelas de campo. La asignación de los tratamientos (`variedades`) a las unidades experimentales (parcelas) fue completamente al azar. Así, el experimento se planteó como un diseño completamente aleatorizado (DCA).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# data is available online:\npath <- \"https://raw.githubusercontent.com/SchmidtPaul/dsfair_quarto/master/data/Mead1993.csv\"\n\ndat <- read_csv(path) # use path from above\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 24 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): variety\ndbl (3): yield, row, col\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  variety yield   row   col\n  <chr>   <dbl> <dbl> <dbl>\n1 v1       25.1     4     2\n2 v1       17.2     1     6\n3 v1       26.4     4     1\n4 v1       16.1     1     4\n5 v1       22.2     1     2\n6 v1       15.9     2     4\n```\n\n\n:::\n:::\n\n\n\n### Formato\n\nAntes de nada, la variedad de columna debe codificarse como un factor, ya que R por defecto la codifica como una variable de carácter. Hay múltiples maneras de hacer esto - aquí hay dos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- dat %>% \n  mutate(variety = as.factor(variety))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- dat %>% \n  mutate(across(variety, ~ as.factor(.x)))\n```\n:::\n\n\n\n## Distribución de los tratamientos\n\nDado que se trata de un experimento que se estableció con un determinado diseño experimental (= un diseño completamente aleatorizado; DCA) - tiene sentido obtener también un plano de campo. Esto se puede hacer a través de `desplot()` de {desplot}:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesplot(\n  data = dat, \n  flip = TRUE, # row 1 on top, not on bottom\n  form = variety ~ col + row, # fill color per variety\n  text = variety, # variety names per plot\n  cex = 1, # variety names: font size\n  main = \"Field layout\", # plot title\n  show.key = FALSE # hide legend \n  )     \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndesplot(\n  data = dat, \n  flip = TRUE, # row 1 on top, not on bottom\n  form = yield ~ col + row, # fill color per variety\n  text = variety, # variety names per plot\n  cex = 1, # variety names: font size\n  main = \"Yield per plot\", # plot title\n  show.key = FALSE # hide legend \n  )     \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## Modelo\nPor último, podemos decidir ajustar un modelo lineal con el rendimiento como variable de respuesta y efectos (fijos) de variedad.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- lm(yield ~ variety, data = dat)\n```\n:::\n\n\n## ANOVA\n\nBasándonos en nuestro modelo, podemos realizar un ANOVA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nANOVA <- anova(mod)\nANOVA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nResponse: yield\n          Df  Sum Sq Mean Sq F value    Pr(>F)    \nvariety    3 1291.48  430.49  23.418 9.439e-07 ***\nResiduals 20  367.65   18.38                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n\n## Comparación de medias\nAdemás de un ANOVA, también se pueden comparar las medias de rendimiento ajustadas entre variedades mediante pruebas post hoc (prueba t, prueba de Tukey, etc.).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_comp <- mod %>% \n  emmeans(specs = ~ variety) %>% # adj. mean per variety\n  cld(adjust = \"Tukey\", Letters = letters) # compact letter display (CLD)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNote: adjust = \"tukey\" was changed to \"sidak\"\nbecause \"tukey\" is only appropriate for one set of pairwise comparisons\n```\n\n\n:::\n\n```{.r .cell-code}\nmean_comp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n variety emmean   SE df lower.CL upper.CL .group\n v3        19.5 1.75 20     14.7     24.3  a    \n v1        20.5 1.75 20     15.7     25.3  a    \n v4        29.9 1.75 20     25.1     34.7   b   \n v2        37.4 1.75 20     32.6     42.2    c  \n\nConfidence level used: 0.95 \nConf-level adjustment: sidak method for 4 estimates \nP value adjustment: tukey method for comparing a family of 4 estimates \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n\n\n:::\n:::\n\n\n\nTenga en cuenta que si desea ver los contrastes/diferencias individuales subyacentes entre medias ajustadas, simplemente añada `details = TRUE` a la sentencia `cld()`. Además, consulte el artículo de resumen \"Visualización compacta de letras\".\n\nPor último, podemos crear un gráfico que muestre tanto los datos brutos como los resultados, es decir, las comparaciones de las medias ajustadas que se basan en el modelo lineal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_caption <- \"Los puntos negros representan los datos brutos. Los puntos rojos y las barras de error representan medias ajustadas con límites de confianza del 95% por variedad. Las medias seguidas de una letra común no son significativamente diferentes según la prueba de Tukey.\"\n\nggplot() +\n  aes(x = variety) +\n  # black dots representing the raw data\n  geom_point(\n    data = dat,\n    aes(y = yield)\n  ) +\n  # red dots representing the adjusted means\n  geom_point(\n    data = mean_comp,\n    aes(y = emmean),\n    color = \"red\",\n    position = position_nudge(x = 0.1)\n  ) +\n  # red error bars representing the confidence limits of the adjusted means\n  geom_errorbar(\n    data = mean_comp,\n    aes(ymin = lower.CL, ymax = upper.CL),\n    color = \"red\",\n    width = 0.1,\n    position = position_nudge(x = 0.1)\n  ) +\n  # red letters \n  geom_text(\n    data = mean_comp,\n    aes(y = emmean, label = str_trim(.group)),\n    color = \"red\",\n    position = position_nudge(x = 0.2),\n    hjust = 0\n  ) +\n  scale_x_discrete(\n    name = \"Variety\"\n  ) +\n  scale_y_continuous(\n    name = \"Yield\",\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.1))\n  ) +\n  theme_classic() +\n  labs(caption = my_caption) +\n  theme(plot.caption = element_textbox_simple(margin = margin(t = 5)),\n        plot.caption.position = \"plot\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nPara calcular la heredabilidad y los Best Linear Unbiased Estimators (BLUE) en R, puedes seguir los pasos que se detallan a continuación. Utilizaremos el paquete `lme4` para ajustar un modelo de efectos mixtos y obtener las estimaciones necesarias.\n\n## Cálculo de la Heredabilidad\nLa heredabilidad en sentido amplio se puede estimar como la proporción de la varianza genética (entre variedades) sobre la varianza total (varianza genética + varianza residual). Para esto, ajustaremos un modelo mixto donde la variedad se considere como un efecto aleatorio.\n\n## Cálculo de BLUEs\nLos BLUEs se obtienen cuando tratamos los efectos de la variedad como fijos en un modelo lineal. En el contexto del diseño completamente aleatorizado (DCA), los BLUEs son simplemente las medias ajustadas (predicciones) para cada variedad.\n\n## Ejemplo\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ajustar el modelo mixto para calcular la heredabilidad\nlibrary(lme4)\n\nmod_mixed <- lmer(yield ~ (1|variety), data = dat)\n\n# Resumen del modelo para obtener las varianzas\nsummary(mod_mixed)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML ['lmerMod']\nFormula: yield ~ (1 | variety)\n   Data: dat\n\nREML criterion at convergence: 144.9\n\nScaled residuals: \n     Min       1Q   Median       3Q      Max \n-1.95560 -0.58695 -0.03299  0.77728  1.48538 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n variety  (Intercept) 68.68    8.288   \n Residual             18.38    4.288   \nNumber of obs: 24, groups:  variety, 4\n\nFixed effects:\n            Estimate Std. Error t value\n(Intercept)   26.820      4.235   6.333\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extraer las varianzas para calcular la heredabilidad\nvar_comp <- as.data.frame(VarCorr(mod_mixed))\nvar_genetic <- var_comp$vcov[1]  # Varianza genética (entre variedades)\nvar_residual <- var_comp$vcov[2] # Varianza residual\n\n# Calcular la heredabilidad en sentido amplio (H^2)\nH2 <- var_genetic / (var_genetic + var_residual)\nH2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7888692\n```\n\n\n:::\n:::\n\n\n### Calcular los BLUEs\nSi la variedad es un efecto fijo, los BLUEs coinciden con las medias ajustadas obtenidas en tu código anterior. Sin embargo, si quieres obtener los BLUEs explícitamente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ajustar un modelo con efectos fijos para la variedad\nmod_fixed <- lm(yield ~ variety, data = dat)\n\n# Obtener los BLUEs\nBLUEs <- emmeans(mod_fixed, ~ variety)\nBLUEs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n variety emmean   SE df lower.CL upper.CL\n v1        20.5 1.75 20     16.8     24.1\n v2        37.4 1.75 20     33.8     41.1\n v3        19.5 1.75 20     15.8     23.1\n v4        29.9 1.75 20     26.2     33.5\n\nConfidence level used: 0.95 \n```\n\n\n:::\n:::\n\n\n### Adición de Heredabilidad y BLUEs al Gráfico\n\nSi deseas agregar la heredabilidad y los BLUEs al gráfico, puedes hacerlo de la siguiente manera:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calcular heredabilidad y obtener BLUEs\nH2 <- round(H2, 2)\n\n# Calcular los BLUEs y las letras de Tukey\nBLUEs <- emmeans(mod_fixed, ~ variety) %>% \n  cld(adjust = \"Tukey\", Letters = letters) %>% \n  as.data.frame()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNote: adjust = \"tukey\" was changed to \"sidak\"\nbecause \"tukey\" is only appropriate for one set of pairwise comparisons\n```\n\n\n:::\n\n```{.r .cell-code}\n# Añadir heredabilidad como un texto en el gráfico\nmy_caption <- paste(\"Los puntos negros representan los datos brutos. Los puntos rojos y las barras de error representan medias ajustadas con límites de confianza del 95% por variedad. Las medias seguidas de una letra común no son significativamente diferentes según la prueba de Tukey.\\nHeredabilidad: \", H2)\n\n# Crear el gráfico\nggplot() +\n  aes(x = variety) +\n  # black dots representing the raw data\n  geom_point(\n    data = dat,\n    aes(y = yield)\n  ) +\n  # red dots representing the adjusted means\n  geom_point(\n    data = BLUEs,\n    aes(y = emmean),\n    color = \"red\",\n    position = position_nudge(x = 0.1)\n  ) +\n  # red error bars representing the confidence limits of the adjusted means\n  geom_errorbar(\n    data = BLUEs,\n    aes(ymin = lower.CL, ymax = upper.CL),\n    color = \"red\",\n    width = 0.1,\n    position = position_nudge(x = 0.1)\n  ) +\n  # red letters \n  geom_text(\n    data = BLUEs,\n    aes(y = emmean, label = str_trim(.group)),\n    color = \"red\",\n    position = position_nudge(x = 0.2),\n    hjust = 0\n  ) +\n  scale_x_discrete(\n    name = \"Variety\"\n  ) +\n  scale_y_continuous(\n    name = \"Yield\",\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.1))\n  ) +\n  theme_classic() +\n  labs(caption = my_caption) +\n  theme(plot.caption = element_textbox_simple(margin = margin(t = 5)),\n        plot.caption.position = \"plot\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nEste código te permite visualizar las medias ajustadas junto con la heredabilidad calculada y los BLUEs.\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}